%\documentclass[a4paper, 12pt, draft]{report}
\documentclass[a4paper, 12pt]{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pscyr}
\usepackage{color}
\usepackage[colorlinks, citecolor=blue, pagecolor=magenta, linkcolor=blue, unicode]{hyperref}
\usepackage[english, russian]{babel}
\usepackage{misccorr}
\usepackage{listings}
\usepackage{indentfirst}

\title{Руководство пользователя Git}
\date{Начало перевода: 30 сентября 2010 г.\linebreak Последняя правка: \today}

\pagestyle{headings}

\begin{document}

\lstset{language=bash, 
		frame=trbl,
		frameround=tttt,
		basicstyle=\ttfamily\small , 
		keywordstyle=\textbf ,		
		commentstyle=\textit
		}

\maketitle
\tableofcontents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% ВВЕДЕНИЕ
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section*{Введение}
\hypertarget{#preface}{}

Git "--- это быстрая распределённая система контроля версиями.

Это руководство рассчитано на тех, кто обладает базовыми знаниями командной
строки Unix, и совершенно не разбирается в git.

\href{#chapter1}{Глава~1. Репозитории и ветки} и 
\href{#chapter2}{Глава~2. Исследование истории git} объясняют как 
получить и изучить проект использующий git. Прочитав эти главы вы поймёте как 
создавать и тестировать отдельные версии программного проекта, восстанавливать 
предыдущие состояния и т.",д. Тех, кто занимается разработкой, заинтересуют главы
\href{#chapter3}{Глава~3. Разработка вместе с git} и 
\href{#chapter4}{Глава~4. Совместная разработка}. Последующие главы 
охватывают более специализированные вопросы.

Наиболее полная документация доступна на страницах \textsf{man} и при вызове
команды \href{http://www.kernel.org/pub/software/scm/git/docs/git-help.html}
{git-help(1)}. Например, для комманды \emph{git clone <repo>}, вы 
можете использовать:

\begin{lstlisting}
$ man git-clone
\end{lstlisting}

или

\begin{lstlisting}
$ git help clone
\end{lstlisting}

Так же вы можете использовать любую программу просмотра руководства
\emph{man}.
Для подробной информации обратитесь к 
\href{http://www.kernel.org/pub/software/scm/git/docs/git-help.html}
{git-help(1)}.

Ещё прочтите \href{#appendixa}{Приложение~А. Быстрый обзор git} для получения
общего представления о командах Git без подробных разъяснений.

%!!!!! этот абзац нужно будет пересмотреть после перевода приложения Б
И наконец, \href{#appendixb}{Приложение~Б. Заметки и список ссылок для этого
руководства} поможет вам в желании сделать это руководство более
полным.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CHAPTER 1
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Репозитории и ветки}
\hypertarget{#chapter1}{}

\section{Как получить репозиторий}

Раз уж вы читаете это руководство, то будет полезно скачать репозиторий git для 
экспериментов.

Лучшим способом сделать это будет использование команды
\href{http://www.kernel.org/pub/software/scm/git/docs/git-clone.html}{git-clone(1)}
для получения копии существующего репозитория. Если у вас ещё нет проектов на 
примете, то вот пара примеров:

\begin{lstlisting}
# git itself (approx. 10MB download):
$ git clone git://git.kernel.org/pub/scm/git/git.git
# the Linux kernel (approx. 150MB download):
$ git clone git://git.kernel.org/pub/scm/linux
                  /kernel/git/torvalds/linux-2.6.git
\end{lstlisting}

Создание копии репозитория может занять много времени для больших проектов, но 
только в первый раз.

Команда клонирования создаёт новую директорию с именем проекта (<<git>> и <<linux-2.6>>
для вышеприведённых примеров. В созданной папке вы увидите файлы проекта, называемые
\href{#def_working_tree}{рабочим деревом (working tree)} вместе со специальной папкой 
<<.git>>, которая содержит всю информацию об истории проекта.



\section{Как создать новую версию проекта}

Git лучше рассмаривать как инструмент для хранения истории набора колекции файлов.
Он хранит истории сжатой, в виде набора взаимосвязанных состояний содержимого
проекта. Каждое такое состояние называется \href{#def_commit}{коммитом (commit)}.

Эти состояния не обязательно идут друг за другом, от старого к новому. Вместо этого
они могут развиваться параллельно, образуюя \href{#def_branch}{ветки (branch)},
которые могут сливаться и разделяться.

Один репозиторий git может отслеживать развитие нескольких ветвей. Он реализует это
введением списка \href{#def_head}{заголовков (heads)}, которые ссылаются на
последние коммиты в каждой ветви. Команда \href{http://www.kernel.org/pub/software/scm/git/docs/git-branch.html}{git-branch(1)}
покажет вам список заголовков ветвей:

\begin{lstlisting}
$ git branch
* master
\end{lstlisting}
%$

Недавно склонированный репозиторий содержит единственную ветку, называему по умолчанию
<<master>>.
% дописать

В большинстве проектов также используются \href{#def_tag}{теги (tags)}. Теги, подобно
заголовкам, ссылаются на историю проекта. Их можно просмотреть с помощью команды
\href{http://www.kernel.org/pub/software/scm/git/docs/git-tag.html}{git-tag(1)}:

\begin{lstlisting}
$ git tag -l
v2.6.11
v2.6.11-tree
v2.6.12
v2.6.12-rc2
v2.6.12-rc3
v2.6.12-rc4
v2.6.12-rc5
v2.6.12-rc6
v2.6.13
...
\end{lstlisting}
%$

Теги всегда указывают на одну и ту же версию проекта, в то время как заголовки
модифицируются вместе с развитием проекта.

Для создания заголовка указывающего на новую ветку одной из версий проекта
осуществляется с помощью команды
\href{http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html}{git-checkout(1)}:

\begin{lstlisting}
$ git checkout -b new v.2.6.13
\end{lstlisting}
%$

Рабочая директория содержащая проект была помечена тегом 2.6.13. Теперь команда
\href{http://www.kernel.org/pub/software/scm/git/docs/git-branch.html}{git-branch(1)}
покажет две ветки. Текущая ветвь помечена <<звёздочкой>>:

\begin{lstlisting}
$ git branch
  master
* new
\end{lstlisting}
%$

Если вы решили, что хотите видеть версию 2.6.17, то вы можете изменить текущую ветвь,
чтобы она указывала на v2.6.17 вместо v2.6.13. Для этого используйте:

\begin{lstlisting}
$ git reset --hard v2.6.17
\end{lstlisting}
%$

Заметьте, что заголовок текущей ветки имеет единственную ссылку на определённое состояние
в истории проекта, поэтому его сброс может лишить вас возможности возвращаться в
предыдущие состояния. Используйте эту команду с осторожностью.


\section{Понятие истории: коммиты}

Каждое изменение в истории проекта отражается в соответствующем коммите. Команда
\href{http://www.kernel.org/pub/software/scm/git/docs/git-show.html}{git-show(1)}
показывает последние коммиты текущей ветки:

\begin{lstlisting}
$ git show
commit 17cf781661e6d38f737f15f53ab552f1e95960d7
Author: Linus Torvalds <torvalds@ppc970.osdl.org.(none)>
Date:   Tue Apr 19 14:11:06 2005 -0700

    Remove duplicate getenv(DB_ENVIRONMENT) call

    Noted by Tony Luck.

diff --git a/init-db.c b/init-db.c
index 65898fa..b002dc6 100644
--- a/init-db.c
+++ b/init-db.c
@@ -7,7 +7,7 @@

 int main(int argc, char **argv)
 {
-       char *sha1_dir = getenv(DB_ENVIRONMENT), *path;
+       char *sha1_dir, *path;
        int len, i;

        if (mkdir(".git", 0755) < 0) {
\end{lstlisting}
%$

Как видите коммит содержит информацию о последнем изменении "--- что оно изменило
и почему.

Каждый коммит содержит 40"=значный шестнадцатиричный идентификатор, иногда называемый
<<именем объекта>> или <<SHA-1 идентификатором>>, который можно увидеть в первой
строке вывода команды \emph{git show}. Обычно вы можете ссылаться на коммит по
короткому имени, как на тег или имя ветки, но это длинное имя также может быть
полезным. Самое главное, это имя является уникальным для коммита. Поэтому когда
вы сообщаете кому"=то ещё имя объека (например, по электронной почте), то вы
гарантируете, что оно ссылается именно на тот объект в репозитории, который вы
имели в виду. Так как имя объекта вычисляется как хеш содержимого коммита, то вы
можете быть уверены, что имя объекта не изменится без изменения данных.

В \href{#chapter7}{Главе~7. Принципы Git} мы увидим, всё что хранится в истории git,
включая файлы данных и содержимое каталогов, есть объекты с именами получеными в
результате вычисления хеша их содержимого.


\subsection{Понятие истории: Коммиты, родители и достижимость}

Каждый коммит (за исключением самого первого коммита проекта) имеет родительский
коммит, который показывает что случилось перед этим коммитом. По цепочке родительских
коммитов, вы, в итоге, придёте в самое начало проекта. 

Тем не менее, эти коммиты не являются простым списком. Git позволяет различным
линиям разработки разветвляться и, затем, объединяться. Точка объединения двух
линий разработки называется <<слиянием>>. Коммиты, представляющие слияния, могут
иметь более одного родителя, представляющего собой последний коммит своей линии
разработки.

Самый наглядный способ увидеть всё это в действии "--- использовать команду
\href{http://www.kernel.org/pub/software/scm/git/docs/gitk.html}{gitk(1)}. 
Запуск gitk на существующем репозитории поможет понять как в git организована
история.

Далее мы увидим, что коммит X является <<доступным>> из коммита Y, если X является
предком Y. Аналогично можно сказать, что Y является потомком X. Или, что существует
цепь родителей, ведущая из коммита Y в коммит X.


\subsection{Понятие истории: Диаграммы истории}

Мы иногда будем представлять истори git в виде диаграммы, как показано ниже. Коммит
изображается символом <<\texttt{\small o}>>, а связи между ними "--- <<->>, 
<<\textbackslash>> и <</>>. Время течёт слева направо:

\begin{lstlisting}
         o--o--o <-- Branch A
        /
 o--o--o <-- master
        \
         o--o--o <-- Branch B
\end{lstlisting}

Если вы хотите указать на конкретный коммит, то замените <<\texttt{\small o}>> на любой другой
символ и номер.


\subsection{Понятие истории: Что такое ветвь?}

Если вы хотите быть точны, то используйте слово <<ветвь>> для обозначения линии
разработки и <<заголовок ветви>> для обозначения ссылки на самый последний коммит
в ветке. В примере выше, заголовок ветки А "--- это указатель на конкретный коммит,
но в то же время мы ссылаемся на список из трёх коммитов, начинающийся с А.

Но чаще всего мы будем использовать термин <<ветвь>> как для веток, так и для
их заголовков, при условии, что это не вызовет путаницы.


\section{Действия с ветвями}

Создание, удаление и изменение ветвей "--- это быстро и легко. Вот краткое изложение
основных команд:

\begin{description}

\item[git branch] \ 
\linebreak список всех ветвей;

\item[git branch <branch>] \ \linebreak
создание новой ветки по имени <branch>, ссылающейся на тот же коммит, 
что и текущая ветка;

\item[git branch <branch> <start-point>] \ \linebreak
создание новой ветки по имени <branch>, ссылающейся на точку <start-point>,
которая может быть как уже используемой веткой, так и тегом;

\item[git branch -d <branch>] \ \linebreak
удаление ветки <branch>. Если эта ветка, которую вы хотите удалить, 
указывает на коммит не доступный из текущей ветки, то команда не будет выполнена
и вы получите предупреждающее сообщение;

\item[git branch -D <branch>] \ \linebreak
даже если эта ветвь указывает на коммит не доступный из текущей ветки, вы можете
знать, что он доступен из другой ветки или тега. В этом случае можно с уверенностью
использовать данную команду, чтобы заставить git без вопросов удалить ветку;

\item[git checkout <branch>] \ \linebreak
делает текущей ветку <branch>, и модифицирует соответствующим образом рабочую
папку;

\item[git checkout -b <new> <start-point>] \ \linebreak
создаёт новую ветвь <new>, ссылающуюся на <start-point>, и переходит в неё.

\end{description}

Специальный символ <<HEAD>> может быть использован как ссылка на текущую ветвь.
В реальности, git использует файл HEAD в папке .git чтобы запомнить какая ветка
является текущей:

\begin{lstlisting}
$ cat .git/HEAD
ref: refs/heads/master
\end{lstlisting}
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% END
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
